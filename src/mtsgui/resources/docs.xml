<?xml version="1.0"?>
<documentation version="2.0.2">
	<plugin type="scene" className="Scene">
		<shortDescr>Scene root element</shortDescr>
		<descr>Tweaking the kd-tree construction parameters is generally not required.</descr>
		<param name="testType" type="string" default="t-test">
			When test case mode is active (Mitusba is started with the -t parameter), this specifies the type of test performed.
			Mitsuba will expect a reference solution file of the name <tt>&lt;sceneName&gt;.ref</tt>.
			When set to <tt>t-test</tt>, a two-sided t-test on equality to the reference will be performed at the (1 - <tt>testThresh</tt>) level (99% by default).
			When set to <tt>relerr</tt>, the test will fail if the relative error exceeds <tt>testThresh</tt>.
		</param>
		<param name="testThresh" type="float" default="0.01">Error threshold for use with <tt>testType</tt></param>
		<param name="importanceSampleLuminaires" type="boolean" default="true">By default, luminaire sampling chooses a luminaire with a probability dependent on the emitted power. Setting this parameter to false switches to uniform sampling.</param>
		<param name="kdClip" type="boolean" default="true">kd-tree construction: Enable primitive clipping? Generally leads to a significant improvement of the resulting tree.</param>
		<param name="kdIntersectionCost" type="float" default="20">kd-tree construction: Relative cost of a triangle intersection operation in the surface area heuristic.</param>
		<param name="kdTraversalCost" type="float" default="15">kd-tree construction: Relative cost of a kd-tree traversal operation in the surface area heuristic.</param>
		<param name="kdEmptyBonus" type="float" default="0.8">kd-tree construction: Bonus factor for cutting away regions of empty space</param>
		<param name="kdStopPrims" type="integer" default="8">kd-tree construction: A kd-tree node containing this many or fewer primitives will not be split</param>
		<child type="integrator" count="1">Requires an integrator</child>
		<child type="camera" count="1">Requires a camera</child>
		<child type="luminaire" count="+">Requires one or more luminaires</child>
		<child type="shape" count="+">Requires one or more shapes</child>
	</plugin>

	<plugin type="integrator" className="SampleIntegrator" abstract="true">
		<shortDescr>Base class of all sampling-based integrators</shortDescr>
		<descr>Base class of all sampling-based integrators</descr>
	</plugin>

	<plugin type="integrator" className="MonteCarloIntegrator" abstract="true" extends="SampleIntegrator">
		<shortDescr>Base class of recursive MC integrators</shortDescr>
		<descr>
			Base class of all recursive Monte Carlo integrators, which compute
			unbiased solutions to the rendering equation (and optionally
			the radiative transfer equation).
		 </descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Longest visualized path length (<tt>-1</tt>=infinite). 
			A value of <tt>1</tt> will visualize only directly visible light sources.
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="10" importance="1">
			Depth to start using russian roulette
		</param>
		<param name="strictNormals" readableName="Strict surface normals" type="boolean" default="false" importance="1">
			<p>
			This parameter specifies the action to be taken when the geometric
			and shading normals of a surface inconsistently classify a ray as
			being located *both* on the front and back-side.
			</p>
			<p>
			When <tt>strictNormals</tt> is set to <tt>false</tt>, the shading normal has 
			precedence, and rendering proceeds normally at the risk of
			introducing small light leaks (this is the default).
			</p>
			<p>
			When <tt>strictNormals</tt> is set to <tt>true</tt>, the random walk is
			terminated when encountering such a situation. This may
			produce black silhouette edges on badly tesselated meshes.
			</p>
		</param>
	</plugin>

	<plugin type="integrator" name="irrcache" readableName="Irradiance cache"
		    className="IrradianceCacheIntegrator">
		<descr>
			Irradiance caching integrator - forwards all radiance computations 
			to an arbitrary nested sampling-based integrator - with one exception:
			whenever a Lambertian surface is intersected, an internal irradiance
			cache is queried for the indirect illumination at the surface position in 
			question. If this query is successful, the sub-integrator is only 
			used to compute the remaining types of radiance (direct, in-scatter, 
			emission) and their sum is returned afterwards.
			When a query is unsuccessful, a new data point is generated by a final
			gathering step.

			The generality of this implementation allows it to be used in conjunction
			with photon mapping (the most likely application) as well as all other 
			sampling-based integrators in Mitsuba. Several optimizations are used to
			improve the achieved interpolation quality, namely irradiance gradients 
			[Ward et al.], neighbor clamping [Krivanek et al.], a screen-space 
			clamping metric and an improved error function [Tabellion et al.].
			By default, this integrator also performs a distributed overture pass before
			rendering, which is recommended to avoid artifacts resulting from the
			addition of samples as rendering proceeds.
		</descr>
		<param name="resolution" readableName="Final Gather resolution" type="integer" default="14">
		   Elevational resolution of the stratified final gather hemisphere.
		   The azimuthal resolution is three times this value. Default: <tt>14</tt>, which
		   leads to <tt>14x(3*14)=588</tt> samples 
		</param>
		<param name="overture" readableName="Overture pass" type="boolean" default="true">
		   If set to true, the irradiance cache will be filled by a
		   parallel overture pass before the main rendering process starts.
		   This is strongly recommended.
		</param>
		<param name="quality" readableName="Quality" type="float" default="1">
		   Quality setting (\kappa in the [Tabellion et al.] paper).
		   A value of 1 should be adequate in most cases.
		</param>
		<param name="gradients" readableName="Irradiance gradients" type="boolean" default="true">
		   Should irradiance gradients be used? Generally, this will
		   significantly improve the interpolation quality.
		</param>
		<param name="clampNeighbor" readableName="Neighbor clamping" type="boolean" default="true">
		   Should neighbor clamping [Krivanek et al.] be used? This 
		   propagates geometry information amongst close-by samples 
		   and generally leads to better sample placement. 
		</param>
		<param name="clampScreen" readableName="Screen-space clamping" type="boolean" default="true">
		   If set to true, the influence region of samples will be clamped
		   using the screen-space metric by [Tabellion et al.]? 
		   Turning this off may lead to excessive sample placement.
		</param>
		<param name="qualityAdjustment" readableName="Quality adjustment" type="float" default=".5">
		   Multiplicative factor for the quality parameter following an
		   overture pass. This can be used to interpolate amongst more
		   samples, creating a visually smoother result. Must be
		   1 or less. 
		</param>
		<param name="debug" readableName="Show sample placement" type="boolean" default="false">
			If set to true, sample locations are visually highlighted as they are generated.
			This won't show samples generated during a separate overture pass, so be sure to turn it off
			if you want to see all of the sample locations.
		</param>
		<param name="influenceMin" readableName="Min. influence region" type="float" default="0.005">
			Minimum influence region of an irradiance sample (relative to scene size, in <tt>[0,1]</tt>)
		</param>
		<param name="influenceMax" readableName="Max. influence region" type="float" default="0.32">
			Maximum influence region of an irradiance sample (default=64*min)
		</param>
		<param name="direct" readableName="Include direct illumination" type="boolean" default="true">
		   If set to false, direct illumination will be suppressed - 
		   useful for checking the interpolation quality
		</param>
		<child type="integrator" count="1" extends="SampleIntegrator">Requires a sampling-based sub-integrator</child>
		<example>
			<integrator type="irrcache">
				<!-- Single-bounce GI on diffuse surfaces, generate debug output -->
				<boolean name="debug" value="true"/>
				<boolean name="direct" value="false"/>
				<br/>
				<integrator type="direct"/>
			</integrator>
		</example>
	</plugin>

	<plugin type="integrator" name="errctrl" readableName="Adaptive integrator"
		    className="ErrorControl">
		<descr>
			Adaptive integrator - runs a secondary integrator until the 
			the computed radiance achieves a specifiable relative error 
			threshold (5% by default) with a certain probability (95% by default). 
			Internally, it uses a Z-test to decide when to stop collecting samples.
			While not entirely rigorous in the statistical sense, this provides a 
			useful stopping criterion. When used in conjunction with image 
			reconstruction filters, this class ensures that neighboring image 
			regions are not unduly biased by placing many samples at a 
			certain position.
		</descr>
		<param name="maxError" readableName="Maximum relative error" type="float" default="0.05">Maximum relative error threshold</param>
		<param name="minSamples" readableName="Minumum number of samples" type="integer" default="64">Minimum numbers of samples (Should be large enough so that reliable variance estimates can be obtained)</param>
		<param name="maxSamples" readableName="Maximum number of samples" type="integer" default="2048">Absolute maximum number of samples to take. The sample collection will stop after this many samples even if the variance is still too high. A negative value will be interpreted as infinity.</param>
		<param name="perPixel" readableName="Apply criterion per pixel" type="boolean" default="false">
		   Specifies whether the relative error criterion is applied
           pixel-by-pixel, or whether the comparison should be made
           against the overall luminance on the film plane. If this
           is set to true, the quality in dark regions will be improved
           at the cost of possibly spending lots of time on them.
		</param>	
		<param name="prob" readableName="Required P-value" type="float" default="0.05" importance="1">Required P-value to accept a sample.</param>
		<param name="verbose" readableName="Verbose" type="boolean" default="false" importance="1">Display convergence statistics</param>
		<child type="integrator" count="1" extends="SampleIntegrator">Requires a sampling-based sub-integrator</child>
		<example>
			<integrator type="errctrl">
				<float name="maxError" value="0.001"/>

				<integrator type="path">
					<integer name="maxDepth" value="1024"/>
				</integrator>
			</integrator>
		</example>
	</plugin>

	<plugin type="integrator" name="direct" readableName="Direct illumination"
			show="true" className="MIDirectIntegrator" extends="SampleIntegrator">
		<descr>
			Direct-only integrator using multiple importance sampling.
			Takes a user-specifiable amount of luminaire
			and BSDF samples and combines them using the power heuristic
			By setting one of the strategies to zero, this 
			class can effectively be turned into a luminaire sampling or
			BSDF sampling-based integrator. Ignores participating media
			if they are present.
		</descr>
		<param name="luminaireSamples" readableName="Luminaire Samples" type="integer" default="1">Number of samples to take using the luminaire sampling technique</param>
		<param name="bsdfSamples" readableName="BSDF Samples" type="integer" default="1">Number of samples to take using the BSDF sampling technique</param>
	</plugin>

	<plugin type="integrator" name="path" readableName="Path tracer"
			show="true" className="MIPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Extended path tracer -- uses multiple importance sampling to combine 
			two sampling strategies, namely BSDF and luminaire sampling. This class also
			supports volumetric absorption, but does not attempt to solve the
			full radiative transfer equation (see <tt>volpath</tt> if this is needed).
		</descr>
	</plugin>
 
	<plugin type="integrator" name="volpath_simple" readableName = "Volumetric path tracer (Simple)"
			show="true" className="SimpleVolumetricPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Volumetric path tracer, which solves the full radiative transfer
			equation in the presence of participating media. 
			Simplified version without multiple importance sampling - this 
			version can be significantly faster than the extended
			version when when rendering heterogeneous participating media using the 
			[Coleman et al.] sampling technique, as fewer attenuation
			evaluations will be performed.
		</descr>
	</plugin>

	<plugin type="integrator" name="volpath" readableName = "Volumetric path tracer (Extended)"
			show="true" className="VolumetricPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Volumetric path tracer, which solves the full radiative transfer
			equation in the presence of participating media. Estimates single
			scattering using both phase function and luminaire sampling and
			combines the two with multiple importance sampling and the power
			heuristic. Afterwards, the phase function sample is reused to
			recursively estimate the multiple scattering component, which saves an
			intersection computation.
			On surfaces, this integrator behaves exactly like the MI path tracer.
		</descr>
	</plugin>

	<plugin type="integrator" name="ptracer" readableName="Adjoint particle tracer" show="true"
			className="ParticleTracer" extends="ImageBasedIntegrator">
		<descr>Particle tracer using an adjoint formulation -- meant primarily for
			verification purposes and test cases. This class follows appendix 
			4.A of Eric Veach's PhD thesis and computes the inner product 
			between emitted radiance and incident importance at the light 
			source (e.g. I = &lt;Le, Wi&gt;). The importance is recursively 
			estimated using a Monte Carlo random walk and adjoint BSDFs are
			used for scattering events. Non-symmetric behavior due to the
			use of shading normals is handled correctly.
			For practical reasons, the integral is simultaneously computed
			for every pixel on the image plane. This is done similarly to 
			path tracing with next event estimation by tracing a
			shadow ray at every surface/volume interaction. 
			An independent accumulation buffer will be assigned to every
			processor so that the rendering process can run in parallel.
			The importance distribution on the camera sensor is chosen 
			to be equivalent to a perspective camera used in a traditional 
			backward ray tracer with uniform sampling on the image plane.
			The number of samples is specified by the camera's sampler
			instance.
		 </descr>
		<param name="granularity" readableName="Work unit granularity" type="integer" default="200000">
			Granularity of the work units used in parallelizing 
			the particle tracing task (default: 200K samples).
			Should be high enough so that sending and accumulating
			the partially exposed films is not the bottleneck.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="10">Depth to start using russian roulette</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
		    Longest visualized path length (<tt>-1</tt>=infinite).
			A value of <tt>1</tt> will produce a black image, since this integrator
			does not visualize directly visible light sources, 
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<example>
			<scene>
				<integrator type="ptracer">
					<!-- Work on chunks of 1M particles, GI up to a depth of 100 -->
					<integer name="granularity" value="1000000"/>
					<integer name="maxDepth" value="100"/>
				</integrator>
				<br/>

				<!-- Luminaires, shapes go here ... -->
				<br/>

				<camera type="perspective">
					<float name="fov" value="45"/>
					<transform name="toWorld">
						<translate x="0" y="0" z="3.5"/>
					</transform>

					<br/>
					<!-- QMC: Use the Hammersley sequence to trace 100M particles -->
					<sampler type="hammersley">
						<integer name="sampleCount" value="100000000"/>
					</sampler>
		
					<br/>
					<!-- Generate a 768x768 EXR image -->
					<film type="exrfilm">
						<integer name="width" value="768"/>
						<integer name="height" value="768"/>
					</film>
				</camera>
			</scene>
		</example>
	</plugin>

	<plugin type="integrator" name="vpl" readableName = "Virtual point light renderer"
			show="true" className="VPLIntegrator" extends="Integrator">
		<descr>
			Rasterization-based global illuminated technique using hardware
			accelerated renderings of the scene under point source illumination. Based on 
			"Instant Radiosity" by Alexander Keller in Computer Graphics Proceedings, 
			Annual Conference Series, SIGGRAPH 97, pp. 49-56. 
		</descr>
		<param name="vplCount" readableName="Number of VPLs" type="integer" default="1000">Total number of virtual point lights that should be rendered</param>
		<param name="shadowMapResolution" readableName="Shadow Map Resolution" type="integer" default="512">Shadow map resolution</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="clamping" readableName="Clamping factor" type="float" default="0.1">Relative clamping factor (0=no clamping, 1=full clamping)</param>
	</plugin>

	<plugin type="integrator" name="photonmapper" readableName="Photon mapper" show="true"
			className="PhotonMapIntegrator" extends="SampleIntegrator">
		<descr>
			Parallel photon mapper with SSE-accelerated lookups. Uses an RGBE-based
			encoding to reduce the storage footprint of photons.
		</descr>
		<param name="directSamples" readableName="Direct samples" type="integer" default="16">Number of luminaire samples for direct illumination</param>
		<param name="glossySamples" readableName="Glossy samples" type="integer" default="32">Number of glossy samples for direct illumination</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Longest visualized path length (<tt>-1</tt>=infinite). 
			A value of <tt>1</tt> will visualize only directly visible light sources.
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="globalPhotons" readableName="Global photons" type="integer" default="200000">Number of photons to collect for the global photon map</param>
		<param name="causticPhotons" readableName="Caustic photons" type="integer" default="0">Number of photons to collect for the caustic photon map</param>
		<param name="volumePhotons" readableName="Volume photons" type="integer" default="0">Number of photons to collect for the volume photon map</param>
		<param name="causticLookupSize" readableName="Caustic photon map lookup size" type="integer" default="120">Amount of photons to consider in a caustic photon map lookup</param>
		<param name="globalLookupSize" readableName="Global photon map lookup size" type="integer" default="120">Amount of photons to consider in a global photon map lookup</param>
		<param name="volumeLookupSize" readableName="Volume photon map lookup size" type="integer" default="120">Amount of photons to consider in a volume photon map lookup</param>
		<param name="granularity" readableName="Work unit granularity" importance="1" type="integer" default="0">Granularity of photon tracing work units (in shot particles, 0 => decide automatically</param>
		<param name="rrDepth" readableName="Russian roulette starting depth" importance="1" type="integer" default="10">Depth to start using russian roulette when tracing photons</param>
		<param name="globalLookupRadius" readableName="Lookup radius (global)" type="float" default="0.05">Radius of lookups in the global photon map (relative to the scene size)</param>
		<param name="causticLookupRadius" readableName="Lookup radius (caustic)" type="float" default="0.0125">Radius of lookups in the caustic photon map (relative to the scene size)</param>
	</plugin>

	<plugin type="integrator" name="ppm" readableName="Progressive photon mapper"
			show="true" className="ProgressivePhotonMapIntegrator" extends="Integrator">
		<descr>
			 Progressive photon mapping implementation. Only handles surface
			 interactions. Parallelization is limited to the local cores.
		</descr>
		<param name="initialRadius" readableName="Initial radius" type="float" default="0">Initial photon query radius (0 = infer based on scene size and camera resolution)</param>
		<param name="alpha" readableName="Size reduction parameter" type="float" default="0.7">Alpha parameter from the paper (influences the speed, at which the photon radius is reduced)</param>
		<param name="photonCount" readableName="Photons per iteration" type="integer" default="100000">Number of photons to shoot in each iteration</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="5">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="10">
			Depth to start using russian roulette
		</param>
		<param name="granularity" readableName="Work unit granularity" type="integer" default="500">
			Granularity of the work units used in parallelizing 
			the particle tracing task (default: 100 samples).
		</param>
		<param name="blockSize" readableName="Block size" type="integer" default="32">
			Block size used to parallelize the photon query passes (default: 32x32 pixels).
		</param>
	</plugin>

	<plugin type="integrator" name="sppm" readableName="Stochastic progressive photon mapper"
			show="true" className="StochasticProgressivePhotonMapIntegrator" extends="Integrator">
		<descr>
			 Stochastic progressive photon mapping implementation. Only handles surface
			 interactions. Parallelization is limited to the local cores.
		</descr>
		<param name="initialRadius" readableName="Initial radius" type="float" default="0">Initial photon query radius (0 = infer based on scene size and camera resolution)</param>
		<param name="alpha" readableName="Size reduction parameter" type="float" default="0.7">Alpha parameter from the paper (influences the speed, at which the photon radius is reduced)</param>
		<param name="photonCount" readableName="Photons per iteration" type="integer" default="250000">Number of photons to shoot in each iteration</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="5">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="10">
			Depth to start using russian roulette
		</param>
		<param name="granularity" readableName="Work unit granularity" type="integer" default="500">
			Granularity of the work units used in parallelizing 
			the particle tracing task (default: 100 samples).
		</param>
		<param name="blockSize" readableName="Block size" type="integer" default="32">
			Block size used to parallelize the photon query passes (default: 32x32 pixels).
		</param>
	</plugin>

	<plugin type="integrator" name="bdpt" readableName="Bidirectional path tracer" show="true"
			className="BidirectionalIntegrator" extends="Integrator">
		<descr>
			Veach-style bidirectional path tracer. Captures all paths except the ones
			with t=0, which would require a finite area sensor. The code parallelizes 
			over multiple cores and machines, but with one caveat: the t=1 sampling 
			strategies require each core to have its own 'light image', where particles
			are accumulated over time. Since these can potentially contribute to any
			pixel, the light images must be at the resolution of the rendered image, and
			transmitting them over the network or through shared memory may become 
			a bottleneck. To avoid this from happening, you have two choices: the 
			first one is to reduce the number of work units so that there is 
			approximately one unit per core (and correspondingly only one image to 
			transmit per core). This can be done by increasing the block size. The 
			second option is to simply disable the t=1 sampling strategies -- see 
			the <tt>enableT1Strategies</tt> parameter. Note that this might reduce the 
			effectiveness of bidirectional path tracing.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
		   Longest visualized path length (<tt>-1</tt>=infinite). 
		   A value of <tt>1</tt> will visualize only directly visible light sources.
		   <tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on. 
		</param>
		<param name="t1Strategies" readableName="Use t=1 strategies" type="boolean" default="true">
			Should the t=1 sampling strategies be enabled? This severely
			increases the amount of information that needs to be transferred
			between workers, which can be a problem for network rendering.
			On the other hand, these strategies are very good at capturing
			caustics and similar effects, hence they might be useful if the
			scene contains them.
		</param>
		<param name="eoRussianRoulette" readableName="Use efficiency-optimized russian roulette" type="boolean" default="true">
		   Should efficiency-optimized russian roulette be used? This
		   technique reduces the (quadratic) amount of necessary 
		   visibility queries in an unbiased manner when they would only
		   lead to very small contributions to the image. Note that
		   this is completely independent of ordinary russian roulette,
		   which is used to limit path lengths.
		</param>
		<param name="directIllumStrategy" readableName="Use direct illumination sampling" type="boolean" default="true">
			Should an optimized direct illumination sampling strategy be used
			for s=1 paths? (as opposed to plain emission sampling). This affects 
			all paths, not just the ones contributing direct illumination.
			Usually a good idea.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Depth to begin using russian roulette (set to <tt>-1</tt> to disable) 
		</param>
	</plugin>

	<plugin type="integrator" name="mlt_kelemen" readableName="Kelemen-style MLT" show="true"
			className="KelemenMLT" extends="Integrator">
		<descr>
			Kelemen-style Metropolis Light Transport implementation. This
			integrator can operate on top of either a simple path tracer or a 
			fully-fledged bidirectional path tracer with multiple importance 
			sampling. Many optimizations are implemented, namely stratified 
			mutations, separate direct illumination, two-stage MLT, and the 
			improved weights proposed by Kelemen et al. For details, see 
			the respective parameter descriptions.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			If set to a positive value, the recursion will stop after this depth. 
			A value of <tt>1</tt> will visualize only directly visible light sources.
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="separateDirectIllum" readableName="Separate direct illumination" type="boolean" default="true">
		   Should direct illumination be handled separately? (i.e. not
		   using MLT) This is usually the right way to go, since direct
		   illumination is easily handled using more optimized rendering
		   techniques that can make use of low-discrepancy point sets.
		   This in turn lets MLT focus on the more difficult parts of the
		   light transport. On the other hand, some scenes use very
		   hard to find paths even for direct illumination, in which case
		   it may make more sense to set this property to <tt>false</tt>.
		</param>
		<param name="directSamples" readableName="Direct samples" type="integer" default="16">
		   When <tt>separateDirectIllum</tt> is set to <tt>true</tt>, this parameter can
		   be used to specify the samples per pixel used to render the
		   direct component. Should be a power of two (otherwise, it will be
		   rounded to the next one). When set to zero or less, the
		   direct illumination component will be hidden, which is useful
		   for analyzing the component rendered by MLT.
	   </param>
	   <param name="bidirectional" readableName="Bidirectional" type="boolean" default="true"> 
		   If set to <tt>true</tt>, the MLT algorithm runs on top of a
		   bidirectional path tracer with multiple importance sampling.
		   Otherwise, the implementation reverts to a basic path tracer.
		   Generally, the bidirectional path tracer should be noticably
		   better, so it's best to this setting at its default.
		</param>
		<param name="twoStage" readableName="Two-stage MLT" type="boolean" default="false">
		   This setting can be very useful to reduce noise in dark regions
		   of the image: it activates two-stage MLT, where a nested MLT renderer
		   first creates a tiny version of the output image. In a second pass, 
		   the full version is then rendered, while making use of information 
		   about the image-space luminance distribution found in the first
		   pass. Two-stage MLT is very useful in making the noise characteristics
		   more uniform over time image -- specifically, since MLT tends to get
		   stuck in very bright regions at the cost of the remainder of the image.
		</param>
		<param name="firstStageSizeReduction" readableName="First-stage size reduction" type="integer" default="16" importance="1">
		   When running two-stage MLT, this parameter influences the size
		   of the downsampled image created in the first pass (i.e. setting this
		   to 16 means that the horizontal/vertical resolution will be 16 times
		   lower). When the two-stage process introduces noisy halos around
		   very bright image regions, it might might be good to reduce this 
		   parameter to 4 or even 1. Generally though, it should be safe to leave
		   it unchanged.
		</param>
		<param name="stratifyLargeMutations" readableName="Stratify mutations" type="boolean" default="true">
			Should the implementation try to achieve a better spread of the
			image plane pixel positions associated with paths? This is done by passing 
			stratified positions to large mutations. The default is
			<tt>true</tt>.
		</param>
		<param name="maxConsecRejections" readableName="Max. consecutive rejections"
			type="integer" default="-1">
		   Max. permitted number of consecutive rejections before forcing
		   acceptance of a proposed transition. Setting this to any value 
		   other than -1 will introduce bias into the algorithm (with higher
		   values resulting in less bias). This parameter exists because it
		   can be used to reduce issues with overly bright pixels (in MLT,
		   these are created when the MLT kernel is 'stuck' in a certain path
		   for a very long time)
		</param>
		<param name="directIllumStrategy" readableName="Use direct illumination sampling" type="boolean" default="true">
		   Should an optimized direct illumination sampling strategy be used
		   for s=1 paths? (as opposed to plain emission sampling). Usually
		   a good idea. Note that this setting only applies when the 
		   bidirectional path tracer is used internally. The optimization
		   affects all paths, not just the ones contributing direct illumination,
		   hence it is completely independent of the <tt>separateDirectIllum</tt>
		   parameter. 
		</param>
		<param name="workUnits" readableName="Parallel work units" type="integer" default="-1">
		   Specifies the number of parallel work units required for
		   multithreaded and network rendering. When set to <tt>-1</tt>, the 
		   amount will default to four times the number of cores. Note that
		   every additional work unit entails a significant amount of 
		   communication overhead (a full-sized floating put image must be 
		   transmitted), hence it is important to set this value as low as 
		   possible, while ensuring that there are enough units to keep all 
		   workers busy.
		</param>
		<param name="kelemenWeights" readableName="Kelemen-style weights" type="boolean" default="true">
		   Should the multiple importance sampling-based weight computation by 
		   Kelemen et al. be used? Otherwise, the implementation falls back
		   to the 'use of expectations' technique from Veach-style MLT.
		</param>
		<param name="luminanceSamples" readableName="Luminance samples" type="integer" default="50000" importance="1">
			Number of samples used to estimate the total luminance 
			received by the camera's sensor.
		</param>
		<param name="pLarge" readableName="Large step probability" type="float" default="0.3" importance="1">
		   Probability of creating large mutations in the [Kelemen et. al] 
		   MLT variant. The default is 0.3.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="5" importance="1">
			Depth to begin using russian roulette (set to <tt>-1</tt> to disable) 
		</param>
	</plugin>

	<plugin type="integrator" name="mlt_veach" readableName="Veach-style MLT" show="true"
			className="MLT" extends="Integrator">
		<descr>
			Veach-style Metropolis Light Transport implementation with support for
			bidirectional mutations, lens perturbations, caustic perturbations and
			multi-chain perturbations. Several optimizations are also implemented, namely
			separate direct illumination, two-stage MLT, and importance sampling of 
			mutation strategies. For details, see the respective parameter descriptions.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			If set to a positive value, the recursion will stop after this depth. 
			A value of <tt>1</tt> will visualize only directly visible light sources.
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="separateDirectIllum" readableName="Separate direct illumination" type="boolean" default="true">
		   Should direct illumination be handled separately? (i.e. not
		   using MLT) This is usually the right way to go, since direct
		   illumination is easily handled using more optimized rendering
		   techniques that can make use of low-discrepancy point sets.
		   This in turn lets MLT focus on the more difficult parts of the
		   light transport. On the other hand, some scenes use very
		   hard to find paths even for direct illumination, in which case
		   it may make more sense to set this property to <tt>false</tt>.
		</param>
		<param name="directSamples" readableName="Direct samples" type="integer" default="16">
		   When <tt>separateDirectIllum</tt> is set to <tt>true</tt>, this parameter can
		   be used to specify the samples per pixel used to render the
		   direct component. Should be a power of two (otherwise, it will be
		   rounded to the next one). When set to zero or less, the
		   direct illumination component will be hidden, which is useful
		   for analyzing the component rendered by MLT.
	   </param>
		<param name="twoStage" readableName="Two-stage MLT" type="boolean" default="false">
		   This setting can be very useful to reduce noise in dark regions
		   of the image: it activates two-stage MLT, where a nested MLT renderer
		   first creates a tiny version of the output image. In a second pass, 
		   the full version is then rendered, while making use of information 
		   about the image-space luminance distribution found in the first
		   pass. Two-stage MLT is very useful in making the noise characteristics
		   more uniform over time image -- specifically, since MLT tends to get
		   stuck in very bright regions at the cost of the remainder of the image.
		</param>
		<param name="firstStageSizeReduction" readableName="First-stage size reduction" type="integer" default="16" importance="1">
		   When running two-stage MLT, this parameter influences the size
		   of the downsampled image created in the first pass (i.e. setting this
		   to 16 means that the horizontal/vertical resolution will be 16 times
		   lower). When the two-stage process introduces noisy halos around
		   very bright image regions, it might might be good to reduce this 
		   parameter to 4 or even 1. Generally though, it should be safe to leave
		   it unchanged.
		</param>
		<param name="maxConsecRejections" readableName="Max. consecutive rejections"
			type="integer" default="-1">
		   Max. permitted number of consecutive rejections before forcing
		   acceptance of a proposed transition. Setting this to any value 
		   other than -1 will introduce bias into the algorithm (with higher
		   values resulting in less bias). This parameter exists because it
		   can be used to reduce issues with overly bright pixels (in MLT,
		   these are created when the MLT kernel is 'stuck' in a certain path
		   for a very long time)
		</param>
		<param name="handleOverlap" readableName="Handle mutator overlap" type="boolean" default="true">
		   Should the acceptance ratio computation account for the overlap
		   of the various different mutation strategies? Usually a good idea.
		   See the separate writeup for further details.
		</param>
		<param name="workUnits" readableName="Parallel work units" type="integer" default="-1">
		   Specifies the number of parallel work units required for
		   multithreaded and network rendering. When set to <tt>-1</tt>, the 
		   amount will default to four times the number of cores. Note that
		   every additional work unit entails a significant amount of 
		   communication overhead (a full-sized floating put image must be 
		   transmitted), hence it is important to set this value as low as 
		   possible, while ensuring that there are enough units to keep all 
		   workers busy.
		</param>
		<param name="luminanceSamples" readableName="Luminance samples" type="integer" default="50000" importance="1">
			Number of samples used to estimate the total luminance 
			received by the camera's sensor.
		</param>
		<param name="bidirectionalMutation" readableName="Bidirectional mutation" type="boolean" default="true" importance="1">
			Selectively enable/disable the bidirectional mutation
		</param>
		<param name="lensPerturbation" readableName="Lens perturbation" type="boolean" default="true" importance="1">
			Selectively enable/disable the lens perturbation
		</param>
		<param name="causticPerturbation" readableName="Caustic perturbation" type="boolean" default="true" importance="1">
			Selectively enable/disable the caustic perturbation
		</param>
		<param name="multiChainPerturbation" readableName="Multi-chain perturbation" type="boolean" default="true" importance="1">
			Selectively enable/disable the bidirectional perturbation
		</param>
		<param name="lensSubpathMutation" readableName="Lens subpath mutation" type="boolean" default="true" importance="1">
			Selectively enable/disable the lens subpath mutation
		</param>
	</plugin>

	<plugin type="subsurface" className="Subsurface" abstract="true">
		<shortDescr>Subsurface integrator base class</shortDescr>
		<descr>
			Abstract subsurface integrator -- can be attached to a shape to compute exitant
			radiance due to internal scattering. By default, the parameters are set to 
			the skim milk data from "A Practical Model for Subsurface scattering" (Jensen et al.)
		</descr>
		<param name="sigmaS" type="spectrum" default="0.7, 1.22, 1.9">Scattering coefficient</param>
		<param name="sigmaT" type="spectrum" default="0.0014, 0.0025, 0.0142">Absorption coefficient</param>
		<param name="eta" type="float" default="1.3">Refractive index of the object</param>
		<param name="sizeMultiplier" type="float" default="1">Scattering/absorption coefficient multiplier - can be used to convert these to world-space units.</param>
	</plugin>

	<plugin type="subsurface" name="dipole" className="IsotropicDipole" extends="Subsurface">
		<shortDescr>Dipole diffusion subsurface integrator</shortDescr>
		<descr>
			Subsurface scattering integrator using Jensen's fast hierarchical 
			dipole approximation scheme.
			("A Rapid Hierarhical Rendering Technique for Translucent 
			Materials" by Herik Wann Jensen and Juan Buhler, in SIGGRAPH 02)
		</descr>
		<param name="maxDepth" type="integer" default="10">Max. depth of the created octree</param>
		<param name="minDelta" type="float" default=".1">Error threshold</param>
	</plugin>
	
	<plugin type="medium" className="Medium" abstract="true">
		<shortDescr>Base class of all participating media</shortDescr>
		<descr>
			Base class of all participating media -- By default, the parameters are set to 
			the skim milk data from "A Practical Model for Subsurface scattering" (Jensen et al.)
		</descr>
		<param name="sigmaS" type="spectrum" default="0.7, 1.22, 1.9">Scattering coefficient</param>
		<param name="sigmaT" type="spectrum" default="0.0014, 0.0025, 0.0142">Absorption coefficient</param>
		<param name="sizeMultiplier" type="float" default="1">Scattering/absorption coefficient multiplier - can be used to convert these to world-space units.</param>
		<child type="phase" count="1">
			Specifies the phase function of the medium. If none is specified,
			the default (<tt>isotropic</tt>) is chosen.
		</child>
	</plugin>

	<plugin type="medium" name="homogeneous" className="HomogeneousMedium" extends="Medium">
		<shortDescr>Homogeneous participating medium</shortDescr>
		<descr>
			Homogeneous participating medium. An arbitrary (manifold) shape
			must be specified as a child object.
		</descr>
		<child type="shape" count="1">Specifies the shape of the medium</child>
	</plugin>

	<plugin type="medium" name="heterogeneous" className="HeterogeneousMedium" extends="Medium">
		<shortDescr>Heterogeneous participating medium</shortDescr>
		<descr>
			Heterogeneous medium class using trilinear interpolation, 
			Simpson quadrature and one of several possible sampling
			strategies. Data files have to be provided in an ASCII
			format as follows:<br/>
			<ul>
				<li> The first three numbers determine the X,Y and Z resolution,
				each of which has to be larger than 2.</li>
				<li>The next six numbers determine the minimum X, Y and Z
				as well as the maximum X, Y and Z values of the enclosing
				axis-aligned bounding box.</li>
				<li>Afterwards, (xres*yres*zres) density samples follow in 
				XYZ order, (e.g. the second entry has coordinate x=2)</li>
			</ul>
		</descr>

		<param name="filename" type="string">File containing sampled volume densities</param>

		<param name="strategy" type="string" default="standard">
			Specifies the used strategy - the four choices are:
			<ul>
				<li><tt>standard</tt>: generate a 'desired' accumulated density by sampling an
					exponentially distributed random variable. Afterwards, try to find the
					distance, at which this much density has been accumulated. Here, the
					composite Simpson's rule is used to integrate density along the ray.</li>
				<li><tt>coleman</tt>: Sampling technique by [Coleman et al., 1967]. Only for media with
					a wavelength-independent extinction coefficient.</li>
				<li><tt>uniform</tt>: Naive variant for verification purposes: uniformly 
					sample a distance along the ray segment, which intersects the volume</li>
				<li><tt>double</tt>: Double integral approach - stupid and slow, but it also works..</li>
			</ul>
		</param>

		<param name="stepSizeFactor" type="float" default="1">
			While integrating density along a ray, approximately one sample
			per voxel is taken - that number can be changed here
		</param>

		<param name="sigma" type="float" default="min(sigmaA+sigmaS)">
			Can be used to override the extinction coefficient used to sample distances 
			in the in-scatter line integral. By default, the smallest spectral sample of 
			<tt>sigmaA+sigmaT</tt> is used.
		</param>
	</plugin>


	<plugin type="phase" name="isotropic" className="IsotropicPhaseFunction" extends="PhaseFunction">
		<shortDescr>Isotropic phase function</shortDescr>
		<descr>
			Basic isotropic phase function
		</descr>
	</plugin>

	<plugin type="phase" name="hg" className="HGPhaseFunction" extends="PhaseFunction">
		<shortDescr>Henyey-Greenstein phase function</shortDescr>
		<descr>
			Phase function by Henyey and Greenstein (1941). Parameterizable
			from backward- through isotropic- to forward scattering.
		</descr>
		<param name="g" type="float" default="0.8">
			Asymmetry parameter of the Henyey-Greenstein phase function. Must
			lie in [-1, 1] where &gt;0 is forward scattering and &lt;0 is backward
			scattering.
		</param>
	</plugin>

	<plugin type="luminaire" className="Luminaire" abstract="true">
		<shortDescr>Abstract luminaire</shortDescr>
		<descr>Abstract implementation of a luminaire. Supports emission and shadow ray sampling and computes related probabilities.</descr>
		<param name="toWorld" type="transform" default="identity">Affine luminaire space to world space transformation</param>
	</plugin>

	<plugin type="luminaire" name="area" className="AreaLuminaire" extends="Luminaire">
		<shortDescr>Lambertian area luminaire</shortDescr>
		<descr>
			Lambertian area light source - can be attached to an arbitrary shape
			contained inside the scene. Shadow rays are generally sampled
			uniformly with respect to surface area, which may lead to high
			variance (e.g. many of the generated samples are facing away
			from the point to be shaded). 
			When the shape in question is a sphere, rays are sampled uniformly 
			wrt. solid angle, which significantly reduces the variance.
			Thus, spheres are recommended whenever there is some flexibility 
			in choosing the luminaire shape.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
		<example>
			<shape type="obj">
				<string name="filename" value="meshes/luminaire_mesh.obj"/>
				<br/>
				<!-- Local to world coordinate transformation -->
				<transform name="toWorld">
					<translate x="0" y="-0.5" z="0"/>
				</transform>
				<br/>
				<!-- Diffuse area luminaire emitting black body radiation at 1500 Kelvin -->
				<luminaire type="area">
					<!-- Can alternatively be specified with the <rgb> or <spectrum> elements -->
					<blackbody name="intensity" temperature="1500"/>
				</luminaire>
				<br/>
				<!-- Black body - do not reflect any light -->
				<bsdf type="lambertian">
					<spectrum name="reflectance" value="0"/>
				</bsdf>
			</shape>
		</example>
	</plugin>

	<plugin type="luminaire" name="collimated" className="CollimatedBeamLuminaire" extends="Luminaire">
		<shortDescr>Collimated beam luminaire</shortDescr>
		<descr>Collimated beam with a configurable thickness. Points from <tt>(0,0,0)-&gt;(0,0,1)</tt> by default - 
			use the <tt>toWorld</tt> parameter to change this. 
		</descr>
		<param name="radius" type="float" default="0.01">World-space beam radius</param>
		<param name="intensity" type="spectrum" default="power/surfaceArea">Intensity of the luminaire. 
			Specify only one of <tt>intensity</tt> and <tt>power.</tt></param>
		<param name="power" type="spectrum" default="1">Power of the luminaire. 
			Specify only one of <tt>intensity</tt> and <tt>power.</tt></param>
	</plugin>

	<plugin type="luminaire" name="point" className="PointLuminaire" extends="Luminaire">
		<shortDescr>Isotropic point source</shortDescr>
		<descr>Positioned at <tt>(0,0,0)</tt> by default - use the
			<tt>toWorld</tt> parameter to change this.</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
	</plugin>

	<plugin type="luminaire" name="spot" className="SpotLuminaire" extends="Luminaire">
		<shortDescr>VRML SpotLight-equivalent luminaire</shortDescr>
		<descr>
			In its local coordinate system, the spot light is positioned at the origin and points into the positive Z
			direction. Its intensity linearly ramps up between <tt>cutoffAngle</tt>
			and <tt>beamWidth</tt>, after which it remains at the maximum value.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
		<param name="cutoffAngle" type="float" default="20">Cutoff angle in degrees</param>
		<param name="beamWidth" type="float" default="cutoffAngle * 3/4">Beam width in degrees</param>
		<example>
			<luminaire type="spot">
				<!-- Spot light placed at (0, -3, 2) pointing towards (1, 1, 4) -->
				<transform name="toWorld">
					<lookAt ox="0" oy="-3" oz="2"
							tx="1" ty="1" tz="4"/>
				</transform>
			</luminaire>
		</example>
	</plugin>

	<plugin type="luminaire" name="constant" className="ConstantLuminaire" extends="Luminaire">
		<shortDescr>Constant background luminaire</shortDescr>
		<descr>Simulates a diffuse, infinitely far-away emitter</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
	</plugin>

	<plugin type="luminaire" name="envmap" className="EnvMapLuminaire" extends="Luminaire">
		<shortDescr>Environment map luminaire</shortDescr>
		<descr>
			Basic environment map implementation without importance sampling.
			Uses the scene's bounding sphere to simulate an infinitely far-away
			light source. Expects an EXR image in latitude-longitude (equirectangular) format.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>

		<example>
			<luminaire type="envmap">
				<!-- Load Paul Debevec's Pisa environment map -->
				<string name="filename" value="pisa.exr"/>
				<br/>
				<!-- Apply a rotation to the environment map -->
				<transform name="toWorld">
					<rotate x="0" y="1" z="0" angle="45"/>
				</transform>
			</luminaire>
		</example>
	</plugin>

	<plugin type="camera" className="Camera" abstract="true">
		<shortDescr>Camera base class</shortDescr>
		<descr>
			A camera turns a sample on the image plane into a 3D ray. 
			For this, it requires two supporting objects: a <tt>Sampler</tt> and a <tt>Film</tt> instance.
		</descr>
		<param name="toWorld" type="transform" default="identity">Affine camera space to world space transformation</param>
	</plugin>
 
	<plugin type="camera" className="PinholeCamera" abstract="true" extends="Camera">
		<shortDescr>Pinhole camera base class</shortDescr>
		<descr>
			Provides solid angle computation
			routines useful for importance-based integrators.
		</descr>
		<param name="fov" type="float" default="90">Field of view of the camera (in degrees)</param>
		<param name="mapSmallerSide" type="boolean" default="true">Specifies which side of the image plane should cover the field of view specified in the <tt>fov</tt> parameter</param>
	</plugin>

	<plugin type="camera" name="perspective" className="PerspectiveCamera" extends="PinholeCamera">
		<shortDescr>Perspective camera model</shortDescr>
		<descr>
			Depth of field can optionally be activated by specifying both focal 
			distance and lens radius (uses a thin lens approximation)
		</descr>
		<param name="focalDistance" type="float" default="0">Distance to the focal plane</param>
		<param name="lensRadius" type="float" default="0">World-space lens radius</param>
		<param name="nearClip" type="float" default="1e-2">Near clipping plane distance</param>
		<param name="farClip" type="float" default="1e4">Far clipping plane distance</param>
		<example>
			<camera type="perspective">
				<float name="fov" value="45"/>
				<transform name="toWorld">
					<translate x="0" y="0" z="3.5"/>
				</transform>

				<br/>
				<!-- 3x3=9 stratified samples per pixel -->
				<sampler type="stratified">
					<integer name="resolution" value="3"/>
				</sampler>
	
				<br/>
				<!-- Generate a 768x768 EXR image -->
				<film type="exrfilm">
					<integer name="width" value="768"/>
					<integer name="height" value="768"/>
					<br/>
					<!-- 4x4 Mitchell-Netravali reconstruction filter -->
					<rfilter type="mitchell"/>
				</film>
			</camera>
		</example>
	</plugin>

	<plugin type="camera" name="orthographic" className="OrthographicCamera" extends="Camera">
		<shortDescr>Orthographic camera model</shortDescr>
		<descr>
			Simple orthographic camera model
		</descr>
		<param name="nearClip" type="float" default="1e-2">Near clipping plane distance</param>
		<param name="farClip" type="float" default="1e4">Far clipping plane distance</param>
		<param name="mapSmallerSide" type="boolean" default="true">Specifies which side of the image plane 
			maps to normalized device coordinates in <tt>[0,1]</tt>
		</param>
	</plugin>
	
	<plugin type="film" className="Film" abstract="true">
		<shortDescr>Abstract Film base class</shortDescr>
		<descr>Used to store samples generated by an Integrator.</descr>
		<param name="width" type="integer" default="512">Horizontal sensor resolution in pixels</param>
		<param name="height" type="integer" default="512">Vertical sensor resolution in pixels</param>
		<param name="cropOffsetX" type="integer" default="0">Horizontal pixel position of the crop window relative to the upper left corner</param>
		<param name="cropOffsetY" type="integer" default="0">Vertical pixel position of the crop window relative to the upper left corner</param>
		<param name="cropWidth" type="integer" default="width">Width of the crop window in pixels</param>
		<param name="cropWeight" type="integer" default="height">Height of the crop window in pixels</param>
		<param name="highQualityEdges" type="boolean" default="false">
			If set to true, regions slightly outside of the film plane will also be sampled, which
			improves the image quality at the edges especially with large reconstruction filters.
		</param>
	</plugin>

	<plugin type="film" name="exrfilm" className="EXRFilm" extends="Film">
		<shortDescr>EXR high dynamic-range film</shortDescr>
		<descr>
			Simple film implementation, which stores the captured image
			as an RGBA-based high dynamic-range EXR file.
			No gamma correction is applied and spectral radiance values
			are converted to linear RGB using the CIE 1931 XYZ color matching 
			functions and ITU-R Rec. BT.709
		</descr>
		<param name="alpha" type="boolean" default="true">Should an alpha channel be added to the output image?</param>
		<param name="banner" type="boolean" default="true">Should a program logo be added to the output image?</param>
	</plugin>

	<plugin type="film" name="pngfilm" className="PNGFilm" extends="Film">
		<shortDescr>PNG low dynamic-range film</shortDescr>
		<descr>
			Simple film implementation, which stores the captured image
			as an RGBA-based low dynamic-range PNG file with gamma correction.
			Spectral radiance values are converted to linear RGB using 
			the CIE 1931 XYZ color matching functions and ITU-R Rec. BT.709
		</descr>
		<param name="alpha" type="boolean" default="true">Should an alpha channel be added to the output image?</param>
		<param name="bpp" type="integer" default="24/32, dep. on alpha">Bits per pixel including alpha (must be 8, 16, 24 or 32)</param>
		<param name="gamma" type="float" default="-1">Gamma value for the correction. Negative values switch to sRGB</param>
	</plugin>

	<plugin type="film" name="mfilm" className="MFilm" extends="Film">
		<shortDescr>MATLAB film</shortDescr>
		<descr>
			Debugging film, which dumps raw luminance values as a 2D array in
			MATLAB M-file format. When test case mode is active, the film writes 
			a triple (luminance, variance, sample count) for every pixel.
		</descr>
		<param name="spectra" type="boolean" default="false">Should all spectral samples be exported? In this case, 
			each pixel will generate several numbers (matching the configured discretization of the color spectrum).
			By default, Mitsuba exports the luminances found using the CIE XYZ color matching curves.
		</param>
	</plugin>

	<plugin type="rfilter" readableName="Box filter" name="box" show="true" className="BoxFilter" extends="ReconstructionFilter">
		<descr>Box filter -- fastest, but prone to aliasing.</descr>
	</plugin>

	<plugin type="rfilter" readableName="Windowed Gaussian filter" name="gaussian" show="true" className="GaussianFilter" extends="ReconstructionFilter">
		<descr>
			Windowed Gaussian filter with configurable extent
			and standard deviation. Often produces pleasing 
			results, but may introduce too much blurring. This
			is the default filter if none is specified.
		</descr>
		<param name="halfSize" readableName="Filter size (half)" type="float" default="2">Half of the filter size in pixels</param>
		<param name="stddev" readableName="Standard deviation" type="float" default=".5">Standard deviation of the Gaussian</param>
	</plugin>

	<plugin type="rfilter" readableName="Windowed Sinc filter" name="wsinc" show="true" className="WindowedSincFilter" extends="ReconstructionFilter">
		<descr>
			Windowed version of the ideal low-pass filter (with a Lanczos
			envelope) -- may produce ringing artifacts near sharp edges. 
		</descr>
		<param name="halfSize" readableName="Filter size (half)" type="float" default="3">Half of the filter size in pixels</param>
		<param name="cycles" readableName="Number of cycles" type="float" default=".5">Number of cycles, after which the sinc function should be truncated</param>
	</plugin>

	<plugin type="rfilter" readableName="Mitchell-Netravali filter" name="mitchell" show="true" className="MitchellNetravaliFilter" extends="ReconstructionFilter">
		<descr>
			Separable reconstruction filter by Mitchell and Netravali.
			D. Mitchell, A. Netravali, Reconstruction filters for computer graphics, 
			Proceedings of SIGGRAPH 88, Computer Graphics 22(4), pp. 221-228, 1988.
		</descr>
		<param name="halfSize" readableName="Filter size (half)" type="float" default="2">Half filter size in pixels</param>
		<param name="B" readableName="B parameter" type="float" default="0.33333">B parameter from the paper</param>
		<param name="C" readableName="C parameter" type="float" default="0.33333">C parameter from the paper</param>

		<example>
			<film type="exrfilm">
				<integer name="width" value="512"/>
				<integer name="height" value="512"/>
				<rfilter type="mitchell">
					<float name="halfSize" value="2"/>
				</rfilter>
			</film>
		</example>
	</plugin>

	<plugin type="rfilter" readableName="Catmull-Rom filter" name="catmullrom" show="true" className="CatmullRomFilter" extends="ReconstrutionFilter">
		<descr>
			Mitchell-Netravali filter with constants B and C configured
			to match the Catmull-Rom spline. Usually does a
			better job at at preserving sharp features at 
			the cost of slightly more ringing.
		</descr>
		<param name="halfSize" readableName="Filter size (half)" type="float" default="2">Half filter size in pixels</param>
	</plugin>

	<plugin type="sampler" name="independent" readableName="Independent sampler" show="true" className="IndependentSampler" extends="Sampler">
		<descr>Independent sample generator - computes independent uniformly distributed random numbers without any kind of stratification.</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">Number of samples per pixel</param>
	</plugin>

	<plugin type="sampler" name="stratified" readableName="Stratified sampler" show="true" className="StratifiedSampler" extends="Sampler">
		<descr>Stratified sample generator - computes stratified samples in 1 and 2 dimensions.
			This only works up to a specified maximum depth, after which
			the implementation falls back to independent sampling.
		</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">Number of samples per pixel (will be rounded up to the next perfect square)</param>
		<param name="depth" readableName="Stratification depth" type="integer" default="3">Depth, up to which which stratified samples are guaranteed to be available.</param>
	</plugin>

	<plugin type="sampler" name="ldsampler" readableName="Low discrepancy sampler" show="true" className="LowDiscrepancySampler" extends="Sampler">
		<descr>
			Adapted version of the low discrepancy sampler in PBRT.
			Provides samples up to a specified depth, after which independent 
			sampling takes over.
		</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">Number of samples per pixel (will be rounded up to the next power of two)</param>
		<param name="depth" readableName="Depth" type="integer" default="3">Depth, up to which which low discrepancy samples are guaranteed to be available.</param>
	</plugin>

	<plugin type="sampler" name="halton" readableName="Halton sequence" className="HaltonSequence" extends="Sampler">
		<descr>
			Deterministic 2D sample generator based on the Halton sequence. Internally
			uses a table of prime numbers to provide elements of the sequence up to a
			depth of 1000. 
			Because of the high correlation amongst neighboring pixels, this
			sampler, by itself, is not meant to be used as a source of random numbers 
			for sample-based integrators such as <tt>direct</tt>, <tt>volpath</tt> etc. 
		</descr>
		<param name="sampleCount" type="integer" default="1">Number of generated samples / samples per pixel</param>
	</plugin>

	<plugin type="sampler" name="hammersley" readableName="Hammersley sequence" className="HammersleySequence" extends="Sampler">
		<descr>
			Deterministic 2D sample generator based on the Hammersley sequence. Internally
			uses a table of prime numbers to provide elements of the sequence up to a
			depth of 1000.
			Because of the high correlation amongst neighboring pixels, this
			sampler, by itself, is not meant to be used as a source of random numbers 
			for sample-based integrators such as <tt>direct</tt>, <tt>volpath</tt> etc. 
		</descr>
		<param name="sampleCount" type="integer" default="1">Number of generated samples / samples per pixel</param>
	</plugin>
</documentation>
