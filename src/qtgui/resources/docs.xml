<?xml version="1.0"?>
<documentation version="2.0.2">
	<plugin type="scene" className="Scene">
		<shortDescr>Scene root element</shortDescr>
		<descr>Tweaking the kd-tree construction parameters is generally not required.</descr>
		<param name="testType" type="string" default="t-test">
			When test case mode is active (Mitusba is started with the -t parameter), this specifies the type of test performed.
			Mitsuba will expect a reference solution file of the name <tt>&lt;sceneName&gt;.ref</tt>.
			When set to <tt>t-test</tt>, a two-sided t-test on equality to the reference will be performed at the (1 - <tt>testThresh</tt>) level (99% by default).
			When set to <tt>relerr</tt>, the test will fail if the relative error exceeds <tt>testThresh</tt>.
		</param>
		<param name="testThresh" type="float" default="0.01">Error threshold for use with <tt>testType</tt></param>
		<param name="importanceSampleLuminaires" type="boolean" default="true">By default, luminaire sampling chooses a luminaire with a probability dependent on the emitted power. Setting this parameter to false switches to uniform sampling.</param>
		<param name="kdClip" type="boolean" default="true">kd-tree construction: Enable primitive clipping? Generally leads to a significant improvement of the resulting tree.</param>
		<param name="kdIntersectionCost" type="float" default="20">kd-tree construction: Relative cost of a triangle intersection operation in the surface area heuristic.</param>
		<param name="kdTraversalCost" type="float" default="15">kd-tree construction: Relative cost of a kd-tree traversal operation in the surface area heuristic.</param>
		<param name="kdEmptyBonus" type="float" default="0.8">kd-tree construction: Bonus factor for cutting away regions of empty space</param>
		<param name="kdStopPrims" type="integer" default="8">kd-tree construction: A kd-tree node containing this many or fewer primitives will not be split</param>
		<child type="integrator" count="1">Requires an integrator</child>
		<child type="camera" count="1">Requires a camera</child>
		<child type="luminaire" count="+">Requires one or more luminaires</child>
		<child type="shape" count="+">Requires one or more shapes</child>
	</plugin>

	<plugin type="integrator" className="SampleIntegrator" abstract="true">
		<shortDescr>Base class of all sampling-based integrators</shortDescr>
		<descr>Base class of all sampling-based integrators</descr>
		<param name="irrSamples" readableName="Irradiance estimates (# Samples)" type="integer" default="32" importance="1">
			How many samples should be taken when estimating the irradiance at a given point in the scene? 
			This attribute is currently only used in conjunction with subsurface integrators and
			can safely be ignored if the scene contains none of them.
		</param>
		<param name="irrIndirect" readableName="Irradiance estimates (Indirect?)" type="boolean" default="true" importance="1">
			When estimating the irradiance at a given point, should indirect illumination be included
			in the final estimate?
			This attribute is currently only used in conjunction with subsurface integrators and
			can safely be ignored if the scene contains none of them.
		</param>
	</plugin>

	<plugin type="integrator" className="MonteCarloIntegrator" abstract="true" extends="SampleIntegrator">
		<shortDescr>Base class of recursive MC integrators</shortDescr>
		<descr>
			Base class of all recursive Monte Carlo integrators, which compute
			unbiased solutions to the rendering equation (and optionally
			the radiative transfer equation).
		 </descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Longest visualized path length (<tt>-1</tt>=infinite). 
			A value of <tt>1</tt> will visualize only directly visible light sources.
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="10" importance="1">
			Depth to start using russian roulette
		</param>
	</plugin>

	<plugin type="integrator" name="irrcache" readableName="Irradiance cache"
		    className="IrradianceCacheIntegrator">
		<descr>
			Irradiance caching integrator - forwards all radiance computations 
			to an arbitrary nested sampling-based integrator - with one exception:
			whenever a Lambertian surface is intersected, an internal irradiance
			cache is queried for the indirect illumination at the surface position in 
			question. If this query is successful, the sub-integrator is only 
			used to compute the remaining types of radiance (direct, in-scatter, 
			emission) and their sum is returned afterwards.
			When a query is unsuccessful, a new data point is generated by a final
			gathering step.

			The generality of this implementation allows it to be used in conjunction
			with photon mapping (the most likely application) as well as all other 
			sampling-based integrators in Mitsuba. Several optimizations are used to
			improve the achieved interpolation quality, namely irradiance gradients 
			[Ward et al.], neighbor clamping [Krivanek et al.], a screen-space 
			clamping metric and an improved error function [Tabellion et al.].
			By default, this integrator also performs a distributed overture pass before
			rendering, which is recommended to avoid artifacts resulting from the
			addition of samples as rendering proceeds.
		</descr>
		<param name="resolution" readableName="Final Gather resolution" type="integer" default="14">
		   Elevational resolution of the stratified final gather hemisphere.
		   The azimuthal resolution is three times this value. Default: <tt>14</tt>, which
		   leads to <tt>14x(3*14)=588</tt> samples 
		</param>
		<param name="overture" readableName="Overture pass" type="boolean" default="true">
		   If set to true, the irradiance cache will be filled by a
		   parallel overture pass before the main rendering process starts.
		   This is strongly recommended.
		</param>
		<param name="quality" readableName="Quality" type="float" default="1">
		   Quality setting (\kappa in the [Tabellion et al.] paper).
		   A value of 1 should be adequate in most cases.
		</param>
		<param name="gradients" readableName="Irradiance gradients" type="boolean" default="true">
		   Should irradiance gradients be used? Generally, this will
		   significantly improve the interpolation quality.
		</param>
		<param name="clampNeighbor" readableName="Neighbor clamping" type="boolean" default="true">
		   Should neighbor clamping [Krivanek et al.] be used? This 
		   propagates geometry information amongst close-by samples 
		   and generally leads to better sample placement. 
		</param>
		<param name="clampScreen" readableName="Screen-space clamping" type="boolean" default="true">
		   If set to true, the influence region of samples will be clamped
		   using the screen-space metric by [Tabellion et al.]? 
		   Turning this off may lead to excessive sample placement.
		</param>
		<param name="qualityAdjustment" readableName="Quality adjustment" type="float" default=".5">
		   Multiplicative factor for the quality parameter following an
		   overture pass. This can be used to interpolate amongst more
		   samples, creating a visually smoother result. Must be
		   1 or less. 
		</param>
		<param name="debug" readableName="Show sample placement" type="boolean" default="false">
			If set to true, sample locations are visually highlighted as they are generated.
			This won't show samples generated during a separate overture pass, so be sure to turn it off
			if you want to see all of the sample locations.
		</param>
		<param name="influenceMin" readableName="Min. influence region" type="float" default="0.005">
			Minimum influence region of an irradiance sample (relative to scene size, in <tt>[0,1]</tt>)
		</param>
		<param name="influenceMax" readableName="Max. influence region" type="float" default="0.32">
			Maximum influence region of an irradiance sample (default=64*min)
		</param>
		<param name="direct" readableName="Include direct illumination" type="boolean" default="true">
		   If set to false, direct illumination will be suppressed - 
		   useful for checking the interpolation quality
		</param>
		<child type="integrator" count="1" extends="SampleIntegrator">Requires a sampling-based sub-integrator</child>
		<example>
			<integrator type="irrcache">
				<!-- Single-bounce GI on diffuse surfaces, generate debug output -->
				<boolean name="debug" value="true"/>
				<boolean name="direct" value="false"/>
				<br/>
				<integrator type="direct"/>
			</integrator>
		</example>
	</plugin>

	<plugin type="integrator" name="errctrl" readableName="Adaptive integrator"
		    className="ErrorControl">
		<descr>
			Adaptive integrator - runs a secondary integrator until the 
			the computed radiance achieves a specifiable relative error 
			threshold (5% by default) with a certain probability (95% by default). 
			Internally, it uses a Z-test to decide when to stop collecting samples.
			While not entirely rigorous in the statistical sense, this provides a 
			useful stopping criterion. When used in conjunction with image 
			reconstruction filters, this class ensures that neighboring image 
			regions are not unduly biased by placing many samples at a 
			certain position.
		</descr>
		<param name="maxError" readableName="Maximum relative error" type="float" default="0.05">Maximum relative error threshold</param>
		<param name="minSamples" readableName="Minumum number of samples" type="integer" default="64">Minimum numbers of samples (Should be large enough so that reliable variance estimates can be obtained)</param>
		<param name="maxSamples" readableName="Maximum number of samples" type="integer" default="2048">Absolute maximum number of samples to take. The sample collection will stop after this many samples even if the variance is still too high. A negative value will be interpreted as infinity.</param>
		<param name="perPixel" readableName="Apply criterion per pixel?" type="boolean" default="false">
		   Specifies whether the relative error criterion is applied
           pixel-by-pixel, or whether the comparison should be made
           against the overall luminance on the film plane. If this
           is set to true, the quality in dark regions will be improved
           at the cost of possibly spending lots of time on them.
		</param>	
		<param name="prob" readableName="Required P-value" type="float" default="0.05" importance="1">Required P-value to accept a sample.</param>
		<param name="verbose" readableName="Verbose" type="boolean" default="false" importance="1">Display convergence statistics</param>
		<child type="integrator" count="1" extends="SampleIntegrator">Requires a sampling-based sub-integrator</child>
		<example>
			<integrator type="errctrl">
				<float name="maxError" value="0.001"/>

				<integrator type="path">
					<integer name="maxDepth" value="1024"/>
				</integrator>
			</integrator>
		</example>
	</plugin>

	<plugin type="integrator" name="direct" readableName="Direct illumination"
			show="true" className="MIDirectIntegrator" extends="SampleIntegrator">
		<descr>
			Direct-only integrator using multiple importance sampling.
			Takes a user-specifiable amount of luminaire
			and BSDF samples and combines them using the power heuristic
			By setting one of the strategies to zero, this 
			class can effectively be turned into a luminaire sampling or
			BSDF sampling-based integrator. Ignores participating media
			if they are present.
		</descr>
		<param name="luminaireSamples" readableName="Luminaire Samples" type="integer" default="1">Number of samples to take using the luminaire sampling technique</param>
		<param name="bsdfSamples" readableName="BSDF Samples" type="integer" default="1">Number of samples to take using the BSDF sampling technique</param>
		<param name="beta" readableName="Power Heuristic coefficient" type="float" default="2" importance="1">Beta coefficient for the power heuristic</param>
	</plugin>

	<plugin type="integrator" name="path" readableName="Path tracer"
			show="true" className="MIPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Extended path tracer -- uses multiple importance sampling to combine 
			two sampling strategies, namely BSDF and luminaire sampling. This class also
			supports volumetric absorption, but does not attempt to solve the
			full radiative transfer equation (see <tt>volpath</tt> if this is needed).
		</descr>
		<param name="beta" readableName="Power Heuristic coefficient" type="float" default="2" importance="1">Beta coefficient for the power heuristic</param>
	</plugin>
 
	<plugin type="integrator" name="volpath_simple" readableName = "Volumetric path tracer (Simple)"
			show="true" className="SimpleVolumetricPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Volumetric path tracer, which solves the full radiative transfer
			equation in the presence of participating media. 
			Simplified version without multiple importance sampling - this 
			version can be significantly faster than the extended
			version when when rendering heterogeneous participating media using the 
			[Coleman et al.] sampling technique, as fewer attenuation
			evaluations will be performed.
		</descr>
	</plugin>

	<plugin type="integrator" name="volpath" readableName = "Volumetric path tracer (Extended)"
			show="true" className="VolumetricPathTracer" extends="MonteCarloIntegrator">
		<descr>
			Volumetric path tracer, which solves the full radiative transfer
			equation in the presence of participating media. Estimates single
			scattering using both phase function and luminaire sampling and
			combines the two with multiple importance sampling and the power
			heuristic. Afterwards, the phase function sample is reused to
			recursively estimate the multiple scattering component, which saves an
			intersection computation.
			On surfaces, this integrator behaves exactly like the MI path tracer.
		</descr>
		<param name="beta" readableName="Power Heuristic coefficient" type="float" default="2" importance="1">Beta coefficient for the power heuristic</param>
	</plugin>

	<plugin type="integrator" name="ptracer" readableName="Adjoint particle tracer" show="true"
			className="ParticleTracer" extends="ImageBasedIntegrator">
		<descr>Particle tracer using an adjoint formulation -- meant primarily for
			verification purposes and test cases. This class follows appendix 
			4.A of Eric Veach's PhD thesis and computes the inner product 
			between emitted radiance and incident importance at the light 
			source (e.g. I = &lt;Le, Wi&gt;). The importance is recursively 
			estimated using a Monte Carlo random walk and adjoint BSDFs are
			used for scattering events. Non-symmetric behavior due to the
			use of shading normals is handled correctly.
			For practical reasons, the integral is simultaneously computed
			for every pixel on the image plane. This is done similarly to 
			path tracing with next event estimation by tracing a
			shadow ray at every surface/volume interaction. 
			An independent accumulation buffer will be assigned to every
			processor so that the rendering process can run in parallel.
			The importance distribution on the camera sensor is chosen 
			to be equivalent to a perspective camera used in a traditional 
			backward ray tracer with uniform sampling on the image plane.
			The number of samples is specified by the camera's sampler
			instance.
		 </descr>
		<param name="granularity" readableName="Work unit granularity" type="integer" default="200000">
			Granularity of the work units used in parallelizing 
			the particle tracing task (default: 200K samples).
			Should be high enough so that sending and accumulating
			the partially exposed films is not the bottleneck.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="10">Depth to start using russian roulette</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
		    Longest visualized path length (<tt>-1</tt>=infinite).
			A value of <tt>1</tt> will produce a black image, since this integrator
			does not visualize directly visible light sources, 
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<example>
			<scene>
				<integrator type="ptracer">
					<!-- Work on chunks of 1M particles, GI up to a depth of 100 -->
					<integer name="granularity" value="1000000"/>
					<integer name="maxDepth" value="100"/>
				</integrator>
				<br/>

				<!-- Luminaires, shapes go here ... -->
				<br/>

				<camera type="perspective">
					<float name="fov" value="45"/>
					<transform name="toWorld">
						<translate x="0" y="0" z="3.5"/>
					</transform>

					<br/>
					<!-- QMC: Use the Hammersley sequence to trace 100M particles -->
					<sampler type="hammersley">
						<integer name="sampleCount" value="100000000"/>
					</sampler>
		
					<br/>
					<!-- Generate a 768x768 EXR image -->
					<film type="exrfilm">
						<integer name="width" value="768"/>
						<integer name="height" value="768"/>
					</film>
				</camera>
			</scene>
		</example>
	</plugin>

	<plugin type="integrator" name="vpl" readableName = "Virtual point light renderer"
			show="true" className="VPLIntegrator" extends="Integrator">
		<descr>
			Rasterization-based global illuminated technique using hardware
			accelerated renderings of the scene under point source illumination. Based on 
			"Instant Radiosity" by Alexander Keller in Computer Graphics Proceedings, 
			Annual Conference Series, SIGGRAPH 97, pp. 49-56. 
		</descr>
		<param name="vplCount" readableName="Number of VPLs" type="integer" default="1000">Total number of virtual point lights that should be rendered</param>
		<param name="shadowMapResolution" readableName="Shadow Map Resolution" type="integer" default="512">Shadow map resolution</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="-1">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="clamping" readableName="Clamping factor" type="float" default="0.1">Relative clamping factor (0=no clamping, 1=full clamping)</param>
	</plugin>

	<plugin type="integrator" name="photonmapper" readableName="Photon mapper" show="true"
			className="PhotonMapIntegrator" extends="SampleIntegrator">
		<descr>
			Parallel photon mapper with SSE-accelerated lookups. Uses an RGBE-based
			encoding to reduce the storage footprint of photons.
		</descr>
		<param name="directSamples" readableName="Direct samples" type="integer" default="1">Number of luminaire samples for direct illumination</param>
		<param name="glossySamples" readableName="Glossy samples" type="integer" default="32">Number of glossy samples for direct illumination</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="40">Depth cutoff when tracing photons</param>
		<param name="maxSpecularDepth" readableName="Max. specular bounces" type="integer" default="6">Depth cutoff when recursively tracing specular materials</param>
		<param name="granularity" readableName="Work unit granularity" importance="1" type="integer" default="1000">Granularity of photon tracing work units (in shot particles)</param>
		<param name="rrDepth" readableName="Russian roulette starting depth" importance="1" type="integer" default="10">Depth to start using russian roulette when tracing photons</param>
		<param name="globalPhotons" readableName="Global photons" type="integer" default="200000">Number of photons to collect for the global photon map</param>
		<param name="causticPhotons" readableName="Caustic photons" type="integer" default="200000">Number of photons to collect for the caustic photon map (if applicable)</param>
		<param name="volumePhotons" readableName="Volume photons" type="integer" default="200000">Number of photons to collect for the volume photon map (if applicable)</param>
		<param name="globalLookupRadius" readableName="Lookup radius (global)" type="float" default="0.05">Radius of lookups in the global photon map (relative to the scene size)</param>
		<param name="causticLookupRadius" readableName="Lookup radius (caustic)" type="float" default="0.0125">Radius of lookups in the caustic photon map (relative to the scene size)</param>
		<param name="volumeLookupRadius" readableName="Lookup radius (volume)" type="float" default="0.05">Radius of lookups in the volume photon map (relative to the scene size)</param>
		<param name="globalMinPhotons" readableName="Min. photons (global)" type="integer" importance="1" default="8">Minimum amount of photons to consider a global photon map lookup valid</param>
		<param name="globalMaxPhotons" readableName="Max. photons (global)" type="integer" importance="1" default="200">Maximum amount of results for global photon map lookups</param>
		<param name="causticMinPhotons" readableName="Min. photons (caustic)" type="integer" importance="1" default="100">Minimum amount of photons to consider a caustic photon map lookup valid</param>
		<param name="causticMaxPhotons" readableName="Max. photons (caustic)" type="integer" importance="1" default="200">Maximum amount of results for caustic photon map lookups</param>
		<param name="volumeMinPhotons" readableName="Min. photons (volume)" type="integer" importance="1" default="8">Minimum amount of photons to consider a volume photon map lookup valid</param>
		<param name="volumeMaxPhotons" readableName="Max. photons (volume)" type="integer" importance="1" default="200">Maximum amount of results for volume photon map lookups</param>
	</plugin>

	<plugin type="integrator" name="ppm" readableName="Progressive photon mapper"
			show="true" className="ProgressivePhotonMapIntegrator" extends="Integrator">
		<descr>
			 Progressive photon mapping implementation. Only handles surface
			 interactions. Parallelization is limited to the local cores.
		</descr>
		<param name="initialRadius" readableName="Initial radius" type="float" default="0">Initial photon query radius (0 = infer based on scene size and camera resolution)</param>
		<param name="alpha" readableName="Size reduction parameter" type="float" default="0.7">Alpha parameter from the paper (influences the speed, at which the photon radius is reduced)</param>
		<param name="photonCount" readableName="Photons per iteration" type="integer" default="100000">Number of photons to shoot in each iteration</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="5">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="10">
			Depth to start using russian roulette
		</param>
		<param name="granularity" readableName="Work unit granularity" type="integer" default="500">
			Granularity of the work units used in parallelizing 
			the particle tracing task (default: 100 samples).
		</param>
		<param name="blockSize" readableName="Block size" type="integer" default="32">
			Block size used to parallelize the photon query passes (default: 32x32 pixels).
		</param>
	</plugin>

	<plugin type="integrator" name="sppm" readableName="Stochastic progressive photon mapper"
			show="true" className="StochasticProgressivePhotonMapIntegrator" extends="Integrator">
		<descr>
			 Stochastic progressive photon mapping implementation. Only handles surface
			 interactions. Parallelization is limited to the local cores.
		</descr>
		<param name="initialRadius" readableName="Initial radius" type="float" default="0">Initial photon query radius (0 = infer based on scene size and camera resolution)</param>
		<param name="alpha" readableName="Size reduction parameter" type="float" default="0.7">Alpha parameter from the paper (influences the speed, at which the photon radius is reduced)</param>
		<param name="photonCount" readableName="Photons per iteration" type="integer" default="250000">Number of photons to shoot in each iteration</param>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="5">
			Longest visualized path length (<tt>-1</tt>=infinite). When a positive value is
			specified, it must be greater or equal to <tt>2</tt>, which corresponds to single-bounce
			(direct-only) illumination.
		</param>
		<param name="rrDepth" readableName="Russian Roulette starting depth" type="integer" default="10">
			Depth to start using russian roulette
		</param>
		<param name="granularity" readableName="Work unit granularity" type="integer" default="500">
			Granularity of the work units used in parallelizing 
			the particle tracing task (default: 100 samples).
		</param>
		<param name="blockSize" readableName="Block size" type="integer" default="32">
			Block size used to parallelize the photon query passes (default: 32x32 pixels).
		</param>
	</plugin>

	<plugin type="integrator" name="bidir" readableName="Bidirectional path tracer (missing)" show="true"
			className="BidirectionalIntegrator" extends="Integrator">
		<descr>
			Veach-style bidirectional path tracer. Captures all paths except the ones
			with t=0, which would require a finite area sensor. Network rendering is
			supported, but with one caveat: each rendering thread will be allocated 
			its own 'light image', which is neccessary to support the t=1 paths (they
			can produce contributions to arbitrary pixels). When choosing a small rendering 
			work unit/block size, many such images will need to be transferred over the 
			network, which may become a bottleneck. In that case, a solution is to increase 
			the block size.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="5">
			If set to a positive value, the recursion will stop after this depth. 
			A value of <tt>1</tt> will visualize only directly visible light sources.
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
	</plugin>

	<plugin type="integrator" name="kelemen" readableName="Kelemen-style MLT (missing)" show="true"
			className="KelemenMLT" extends="Integrator">
		<descr>
			Kelemen-style Metropolis Light Transport implementation. Internally uses
			a bidirectional path tracer with multiple importance sampling to compute
			sample contributions. Direct illumination is computed in a separate pass.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="5">
			If set to a positive value, the recursion will stop after this depth. 
			A value of <tt>1</tt> will visualize only directly visible light sources.
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="luminanceSamples" readableName="Luminance samples" type="integer" default="50000">
			Number of samples to use in estimating the total luminance over the viewport
		</param>
		<param name="directSamples" readableName="Direct illumination samples" type="integer" default="16">
			Number of direct illumination samples taken for each pixel
		</param>
		<param name="pLarge" readableName="Large step probability" type="float" default="0.3">
			Probability of taking large steps
		</param>
	</plugin>

	<plugin type="integrator" name="mlt" readableName="Veach-style MLT (missing)" show="true"
			className="MLT" extends="Integrator">
		<descr>
			Veach-style Metropolis Light Transport implementation with support for
			bidirectional mutations, lens perturbations, caustic perturbations and
			multi-chain perturbations. Direct illumination is computed in a separate pass.
		</descr>
		<param name="maxDepth" readableName="Maximum depth" type="integer" default="5">
			If set to a positive value, the recursion will stop after this depth. 
			A value of <tt>1</tt> will visualize only directly visible light sources.
			<tt>2</tt> will lead to single-bounce (direct-only) illumination, and so on.
		</param>
		<param name="initialSamples" readableName="Initial samples" type="integer" default="50000">
			Number of samples taken to find the initial set of paths and to
			estimate the total luminance over the viewport
		</param>
		<param name="initialPaths" readableName="Initial paths" type="integer" default="100">
			Initial number of MLT processes running in parallel
		</param>
		<param name="directSamples" readableName="Direct illumination samples" type="integer" default="16">
			Number of direct illumination samples taken for each pixel
		</param>
		<param name="bidirMutator" readableName="Bidirectional mutator" type="boolean" default="true">
			Should the bidirectional mutator be used?
		</param>
		<param name="lensMutator" readableName="Lens mutator" type="boolean" default="true">
			Should the lens mutator be used?
		</param>
		<param name="causticMutator" readableName="Caustic mutator" type="boolean" default="true">
			Should the caustic mutator be used?
		</param>
		<param name="multiChainMutator" readableName="Multi-chain mutator" type="boolean" default="true">
			Should the multi-chain mutator be used?
		</param>
	</plugin>

	<plugin type="subsurface" className="Subsurface" abstract="true">
		<shortDescr>Subsurface integrator base class</shortDescr>
		<descr>
			Abstract subsurface integrator -- can be attached to a shape to compute exitant
			radiance due to internal scattering. By default, the parameters are set to 
			the skim milk data from "A Practical Model for Subsurface scattering" (Jensen et al.)
		</descr>
		<param name="sigmaS" type="spectrum" default="0.7, 1.22, 1.9">Scattering coefficient</param>
		<param name="sigmaT" type="spectrum" default="0.0014, 0.0025, 0.0142">Absorption coefficient</param>
		<param name="eta" type="float" default="1.3">Refractive index of the object</param>
		<param name="sizeMultiplier" type="float" default="1">Scattering/absorption coefficient multiplier - can be used to convert these to world-space units.</param>
	</plugin>

	<plugin type="subsurface" name="dipole" className="IsotropicDipole" extends="Subsurface">
		<shortDescr>Dipole diffusion subsurface integrator</shortDescr>
		<descr>
			Subsurface scattering integrator using Jensen's fast hierarchical 
			dipole approximation scheme.
			("A Rapid Hierarhical Rendering Technique for Translucent 
			Materials" by Herik Wann Jensen and Juan Buhler, in SIGGRAPH 02)
		</descr>
		<param name="maxDepth" type="integer" default="10">Max. depth of the created octree</param>
		<param name="minDelta" type="float" default=".1">Error threshold</param>
	</plugin>
	
	<plugin type="medium" className="Medium" abstract="true">
		<shortDescr>Base class of all participating media</shortDescr>
		<descr>
			Base class of all participating media -- By default, the parameters are set to 
			the skim milk data from "A Practical Model for Subsurface scattering" (Jensen et al.)
		</descr>
		<param name="sigmaS" type="spectrum" default="0.7, 1.22, 1.9">Scattering coefficient</param>
		<param name="sigmaT" type="spectrum" default="0.0014, 0.0025, 0.0142">Absorption coefficient</param>
		<param name="sizeMultiplier" type="float" default="1">Scattering/absorption coefficient multiplier - can be used to convert these to world-space units.</param>
		<child type="phase" count="1">
			Specifies the phase function of the medium. If none is specified,
			the default (<tt>isotropic</tt>) is chosen.
		</child>
	</plugin>

	<plugin type="medium" name="homogeneous" className="HomogeneousMedium" extends="Medium">
		<shortDescr>Homogeneous participating medium</shortDescr>
		<descr>
			Homogeneous participating medium. An arbitrary (manifold) shape
			must be specified as a child object.
		</descr>
		<child type="shape" count="1">Specifies the shape of the medium</child>
	</plugin>

	<plugin type="medium" name="heterogeneous" className="HeterogeneousMedium" extends="Medium">
		<shortDescr>Heterogeneous participating medium</shortDescr>
		<descr>
			Heterogeneous medium class using trilinear interpolation, 
			Simpson quadrature and one of several possible sampling
			strategies. Data files have to be provided in an ASCII
			format as follows:<br/>
			<ul>
				<li> The first three numbers determine the X,Y and Z resolution,
				each of which has to be larger than 2.</li>
				<li>The next six numbers determine the minimum X, Y and Z
				as well as the maximum X, Y and Z values of the enclosing
				axis-aligned bounding box.</li>
				<li>Afterwards, (xres*yres*zres) density samples follow in 
				XYZ order, (e.g. the second entry has coordinate x=2)</li>
			</ul>
		</descr>

		<param name="filename" type="string">File containing sampled volume densities</param>

		<param name="strategy" type="string" default="standard">
			Specifies the used strategy - the four choices are:
			<ul>
				<li><tt>standard</tt>: generate a 'desired' accumulated density by sampling an
					exponentially distributed random variable. Afterwards, try to find the
					distance, at which this much density has been accumulated. Here, the
					composite Simpson's rule is used to integrate density along the ray.</li>
				<li><tt>coleman</tt>: Sampling technique by [Coleman et al., 1967]. Only for media with
					a wavelength-independent extinction coefficient.</li>
				<li><tt>uniform</tt>: Naive variant for verification purposes: uniformly 
					sample a distance along the ray segment, which intersects the volume</li>
				<li><tt>double</tt>: Double integral approach - stupid and slow, but it also works..</li>
			</ul>
		</param>

		<param name="stepSizeFactor" type="float" default="1">
			While integrating density along a ray, approximately one sample
			per voxel is taken - that number can be changed here
		</param>

		<param name="sigma" type="float" default="min(sigmaA+sigmaS)">
			Can be used to override the extinction coefficient used to sample distances 
			in the in-scatter line integral. By default, the smallest spectral sample of 
			<tt>sigmaA+sigmaT</tt> is used.
		</param>
	</plugin>


	<plugin type="phase" name="isotropic" className="IsotropicPhaseFunction" extends="PhaseFunction">
		<shortDescr>Isotropic phase function</shortDescr>
		<descr>
			Basic isotropic phase function
		</descr>
	</plugin>

	<plugin type="phase" name="hg" className="HGPhaseFunction" extends="PhaseFunction">
		<shortDescr>Henyey-Greenstein phase function</shortDescr>
		<descr>
			Phase function by Henyey and Greenstein (1941). Parameterizable
			from backward- through isotropic- to forward scattering.
		</descr>
		<param name="g" type="float" default="0.8">
			Asymmetry parameter of the Henyey-Greenstein phase function. Must
			lie in [-1, 1] where &gt;0 is forward scattering and &lt;0 is backward
			scattering.
		</param>
	</plugin>

	<plugin type="luminaire" className="Luminaire" abstract="true">
		<shortDescr>Abstract luminaire</shortDescr>
		<descr>Abstract implementation of a luminaire. Supports emission and shadow ray sampling and computes related probabilities.</descr>
		<param name="toWorld" type="transform" default="identity">Affine luminaire space to world space transformation</param>
	</plugin>

	<plugin type="luminaire" name="area" className="AreaLuminaire" extends="Luminaire">
		<shortDescr>Lambertian area luminaire</shortDescr>
		<descr>
			Lambertian area light source - can be attached to an arbitrary shape
			contained inside the scene. Shadow rays are generally sampled
			uniformly with respect to surface area, which may lead to high
			variance (e.g. many of the generated samples are facing away
			from the point to be shaded). 
			When the shape in question is a sphere, rays are sampled uniformly 
			wrt. solid angle, which significantly reduces the variance.
			Thus, spheres are recommended whenever there is some flexibility 
			in choosing the luminaire shape.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
		<example>
			<shape type="obj">
				<string name="filename" value="meshes/luminaire_mesh.obj"/>
				<br/>
				<!-- Local to world coordinate transformation -->
				<transform name="toWorld">
					<translate x="0" y="-0.5" z="0"/>
				</transform>
				<br/>
				<!-- Diffuse area luminaire emitting black body radiation at 1500 Kelvin -->
				<luminaire type="area">
					<!-- Can alternatively be specified with the <rgb> or <spectrum> elements -->
					<blackbody name="intensity" temperature="1500"/>
				</luminaire>
				<br/>
				<!-- Black body - do not reflect any light -->
				<bsdf type="lambertian">
					<spectrum name="reflectance" value="0"/>
				</bsdf>
			</shape>
		</example>
	</plugin>

	<plugin type="luminaire" name="collimated" className="CollimatedBeamLuminaire" extends="Luminaire">
		<shortDescr>Collimated beam luminaire</shortDescr>
		<descr>Collimated beam with a configurable thickness. Points from <tt>(0,0,0)-&gt;(0,0,1)</tt> by default - 
			use the <tt>toWorld</tt> parameter to change this. 
		</descr>
		<param name="radius" type="float" default="0.01">World-space beam radius</param>
		<param name="intensity" type="spectrum" default="power/surfaceArea">Intensity of the luminaire. 
			Specify only one of <tt>intensity</tt> and <tt>power.</tt></param>
		<param name="power" type="spectrum" default="1">Power of the luminaire. 
			Specify only one of <tt>intensity</tt> and <tt>power.</tt></param>
	</plugin>

	<plugin type="luminaire" name="point" className="PointLuminaire" extends="Luminaire">
		<shortDescr>Isotropic point source</shortDescr>
		<descr>Positioned at <tt>(0,0,0)</tt> by default - use the
			<tt>toWorld</tt> parameter to change this.</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
	</plugin>

	<plugin type="luminaire" name="spot" className="SpotLuminaire" extends="Luminaire">
		<shortDescr>VRML SpotLight-equivalent luminaire</shortDescr>
		<descr>
			In its local coordinate system, the spot light is positioned at the origin and points into the positive Z
			direction. Its intensity linearly ramps up between <tt>cutoffAngle</tt>
			and <tt>beamWidth</tt>, after which it remains at the maximum value.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
		<param name="cutoffAngle" type="float" default="20">Cutoff angle in degrees</param>
		<param name="beamWidth" type="float" default="cutoffAngle * 3/4">Beam width in degrees</param>
		<example>
			<luminaire type="spot">
				<!-- Spot light placed at (0, -3, 2) pointing towards (1, 1, 4) -->
				<transform name="toWorld">
					<lookAt ox="0" oy="-3" oz="2"
							tx="1" ty="1" tz="4"/>
				</transform>
			</luminaire>
		</example>
	</plugin>

	<plugin type="luminaire" name="constant" className="ConstantLuminaire" extends="Luminaire">
		<shortDescr>Constant background luminaire</shortDescr>
		<descr>Simulates a diffuse, infinitely far-away emitter</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>
	</plugin>

	<plugin type="luminaire" name="envmap" className="EnvMapLuminaire" extends="Luminaire">
		<shortDescr>Environment map luminaire</shortDescr>
		<descr>
			Basic environment map implementation without importance sampling.
			Uses the scene's bounding sphere to simulate an infinitely far-away
			light source. Expects an EXR image in latitude-longitude (equirectangular) format.
		</descr>
		<param name="intensity" type="spectrum" default="1">Intensity of the luminaire</param>

		<example>
			<luminaire type="envmap">
				<!-- Load Paul Debevec's Pisa environment map -->
				<string name="filename" value="pisa.exr"/>
				<br/>
				<!-- Apply a rotation to the environment map -->
				<transform name="toWorld">
					<rotate x="0" y="1" z="0" angle="45"/>
				</transform>
			</luminaire>
		</example>
	</plugin>

	<plugin type="camera" className="Camera" abstract="true">
		<shortDescr>Camera base class</shortDescr>
		<descr>
			A camera turns a sample on the image plane into a 3D ray. 
			For this, it requires two supporting objects: a <tt>Sampler</tt> and a <tt>Film</tt> instance.
		</descr>
		<param name="toWorld" type="transform" default="identity">Affine camera space to world space transformation</param>
	</plugin>
 
	<plugin type="camera" className="PinholeCamera" abstract="true" extends="Camera">
		<shortDescr>Pinhole camera base class</shortDescr>
		<descr>
			Provides solid angle computation
			routines useful for importance-based integrators.
		</descr>
		<param name="fov" type="float" default="90">Field of view of the camera (in degrees)</param>
		<param name="mapSmallerSide" type="boolean" default="true">Specifies which side of the image plane should cover the field of view specified in the <tt>fov</tt> parameter</param>
	</plugin>

	<plugin type="camera" name="perspective" className="PerspectiveCamera" extends="PinholeCamera">
		<shortDescr>Perspective camera model</shortDescr>
		<descr>
			Depth of field can optionally be activated by specifying both focal 
			distance and lens radius (uses a thin lens approximation)
		</descr>
		<param name="focalDistance" type="float" default="0">Distance to the focal plane</param>
		<param name="lensRadius" type="float" default="0">World-space lens radius</param>
		<param name="nearClip" type="float" default="1e-2">Near clipping plane distance</param>
		<param name="farClip" type="float" default="1e4">Far clipping plane distance</param>
		<example>
			<camera type="perspective">
				<float name="fov" value="45"/>
				<transform name="toWorld">
					<translate x="0" y="0" z="3.5"/>
				</transform>

				<br/>
				<!-- 3x3=9 stratified samples per pixel -->
				<sampler type="stratified">
					<integer name="resolution" value="3"/>
				</sampler>
	
				<br/>
				<!-- Generate a 768x768 EXR image -->
				<film type="exrfilm">
					<integer name="width" value="768"/>
					<integer name="height" value="768"/>
					<br/>
					<!-- 4x4 Mitchell-Netravali reconstruction filter -->
					<rfilter type="mitchell"/>
				</film>
			</camera>
		</example>
	</plugin>

	<plugin type="camera" name="orthographic" className="OrthographicCamera" extends="Camera">
		<shortDescr>Orthographic camera model</shortDescr>
		<descr>
			Simple orthographic camera model
		</descr>
		<param name="nearClip" type="float" default="1e-2">Near clipping plane distance</param>
		<param name="farClip" type="float" default="1e4">Far clipping plane distance</param>
		<param name="mapSmallerSide" type="boolean" default="true">Specifies which side of the image plane 
			maps to normalized device coordinates in <tt>[0,1]</tt>
		</param>
	</plugin>
	
	<plugin type="film" className="Film" abstract="true">
		<shortDescr>Abstract Film base class</shortDescr>
		<descr>Used to store samples generated by an Integrator.</descr>
		<param name="width" type="integer" default="512">Horizontal sensor resolution in pixels</param>
		<param name="height" type="integer" default="512">Vertical sensor resolution in pixels</param>
		<param name="cropOffsetX" type="integer" default="0">Horizontal pixel position of the crop window relative to the upper left corner</param>
		<param name="cropOffsetY" type="integer" default="0">Vertical pixel position of the crop window relative to the upper left corner</param>
		<param name="cropWidth" type="integer" default="width">Width of the crop window in pixels</param>
		<param name="cropWeight" type="integer" default="height">Height of the crop window in pixels</param>
		<param name="highQualityEdges" type="boolean" default="false">
			If set to true, regions slightly outside of the film plane will also be sampled, which
			improves the image quality at the edges especially with large reconstruction filters.
		</param>
	</plugin>

	<plugin type="film" name="exrfilm" className="EXRFilm" extends="Film">
		<shortDescr>EXR high dynamic-range film</shortDescr>
		<descr>
			Simple film implementation, which stores the captured image
			as an RGBA-based high dynamic-range EXR file.
			No gamma correction is applied and spectral radiance values
			are converted to linear RGB using the CIE 1931 XYZ color matching 
			functions and ITU-R Rec. BT.709
		</descr>
		<param name="alpha" type="boolean" default="true">Should an alpha channel be added to the output image?</param>
		<param name="banner" type="boolean" default="true">Should a program logo be added to the output image?</param>
	</plugin>

	<plugin type="film" name="pngfilm" className="PNGFilm" extends="Film">
		<shortDescr>PNG low dynamic-range film</shortDescr>
		<descr>
			Simple film implementation, which stores the captured image
			as an RGBA-based low dynamic-range PNG file with gamma correction.
			Spectral radiance values are converted to linear RGB using 
			the CIE 1931 XYZ color matching functions and ITU-R Rec. BT.709
		</descr>
		<param name="alpha" type="boolean" default="true">Should an alpha channel be added to the output image?</param>
		<param name="bpp" type="integer" default="24/32, dep. on alpha">Bits per pixel including alpha (must be 8, 16, 24 or 32)</param>
		<param name="gamma" type="float" default="-1">Gamma value for the correction. Negative values switch to sRGB</param>
	</plugin>

	<plugin type="film" name="mfilm" className="MFilm" extends="Film">
		<shortDescr>MATLAB film</shortDescr>
		<descr>
			Debugging film, which dumps raw luminance values as a 2D array in
			MATLAB M-file format. When test case mode is active, the film writes 
			a triple (luminance, variance, sample count) for every pixel.
		</descr>
		<param name="spectra" type="boolean" default="false">Should all spectral samples be exported? In this case, 
			each pixel will generate several numbers (matching the configured discretization of the color spectrum).
			By default, Mitsuba exports the luminances found using the CIE XYZ color matching curves.
		</param>
	</plugin>

	<plugin type="rfilter" readableName="Box filter" name="box" show="true" className="BoxFilter" extends="ReconstructionFilter">
		<descr>Box filter -- fastest, but prone to aliasing.</descr>
	</plugin>

	<plugin type="rfilter" readableName="Windowed Gaussian filter" name="gaussian" show="true" className="GaussianFilter" extends="ReconstructionFilter">
		<descr>
			Windowed Gaussian filter with configurable extent
			and standard deviation. Often produces pleasing 
			results, but may introduce too much blurring. This
			is the default filter if none is specified.
		</descr>
		<param name="halfSize" readableName="Filter size (half)" type="float" default="2">Half of the filter size in pixels</param>
		<param name="stddev" readableName="Standard deviation" type="float" default=".5">Standard deviation of the Gaussian</param>
	</plugin>

	<plugin type="rfilter" readableName="Windowed Sinc filter" name="wsinc" show="true" className="WindowedSincFilter" extends="ReconstructionFilter">
		<descr>
			Windowed version of the ideal low-pass filter (with a Lanczos
			envelope) -- may produce ringing artifacts near sharp edges. 
		</descr>
		<param name="halfSize" readableName="Filter size (half)" type="float" default="3">Half of the filter size in pixels</param>
		<param name="cycles" readableName="Number of cycles" type="float" default=".5">Number of cycles, after which the sinc function should be truncated</param>
	</plugin>

	<plugin type="rfilter" readableName="Mitchell-Netravali filter" name="mitchell" show="true" className="MitchellNetravaliFilter" extends="ReconstructionFilter">
		<descr>
			Separable reconstruction filter by Mitchell and Netravali.
			D. Mitchell, A. Netravali, Reconstruction filters for computer graphics, 
			Proceedings of SIGGRAPH 88, Computer Graphics 22(4), pp. 221-228, 1988.
		</descr>
		<param name="halfSize" readableName="Filter size (half)" type="float" default="2">Half filter size in pixels</param>
		<param name="B" readableName="B parameter" type="float" default="0.33333">B parameter from the paper</param>
		<param name="C" readableName="C parameter" type="float" default="0.33333">C parameter from the paper</param>

		<example>
			<film type="exrfilm">
				<integer name="width" value="512"/>
				<integer name="height" value="512"/>
				<rfilter type="mitchell">
					<float name="halfSize" value="2"/>
				</rfilter>
			</film>
		</example>
	</plugin>

	<plugin type="rfilter" readableName="Catmull-Rom filter" name="catmullrom" show="true" className="CatmullRomFilter" extends="ReconstrutionFilter">
		<descr>
			Mitchell-Netravali filter with constants B and C configured
			to match the Catmull-Rom spline. Usually does a
			better job at at preserving sharp features at 
			the cost of slightly more ringing.
		</descr>
		<param name="halfSize" readableName="Filter size (half)" type="float" default="2">Half filter size in pixels</param>
	</plugin>

	<plugin type="sampler" name="independent" readableName="Independent sampler" show="true" className="IndependentSampler" extends="Sampler">
		<descr>Independent sample generator - returns independent uniformly distributed random numbers on <tt>[0,1)</tt> and <tt>[0, 1)x[0, 1)</tt>.</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="1">Number of generated samples / samples per pixel.</param>
	</plugin>

	<plugin type="sampler" name="stratified" readableName="Stratified sampler" show="true" className="StratifiedSampler" extends="Sampler">
		<descr>
			Stratified sample generator. Given a resolution <tt>R</tt> and a depth <tt>D</tt>, it 
			generates <tt>R*R</tt> samples, each of which can be queried for up to <tt>D</tt> 1- 
			or 2-dimensional vectors by an integrator. The returned 1D/2D-vectors of a particular depth
			have the property of being stratified over all <tt>R*R</tt> samples. When
			the maximum depth is exceeded, this implementation reverts to independent sampling.
		</descr>
		<param name="resolution" readableName="Stratification resolution" type="integer" default="2">Stratification resolution of the sample space. The default results in 2x2=4 samples per pixel</param>
		<param name="depth" readableName="Stratification depth" type="integer" default="3">Depth, up to which which stratified samples are guaranteed to be available.</param>
	</plugin>

	<plugin type="sampler" name="ldsampler" readableName="Low discrepancy sampler" show="true" className="LowDiscrepancySampler" extends="Sampler">
		<descr>
			Adapted version of the low discrepancy sampler in PBRT.
			Provides samples up to a specified depth, after which independent 
			sampling takes over.
		</descr>
		<param name="sampleCount" readableName="Samples per pixel" type="integer" default="4">Number of generated samples / samples per pixel</param>
		<param name="depth" readableName="Depth" type="integer" default="3">Depth, up to which which low discrepancy samples are guaranteed to be available.</param>
	</plugin>

	<plugin type="sampler" name="halton" readableName="Halton sequence" className="HaltonSequence" extends="Sampler">
		<descr>
			Deterministic 2D sample generator based on the Halton sequence. Internally
			uses a table of prime numbers to provide elements of the sequence up to a
			depth of 1000. 
			Because of the high correlation amongst neighboring pixels, this
			sampler, by itself, is not meant to be used as a source of random numbers 
			for sample-based integrators such as <tt>direct</tt>, <tt>volpath</tt> etc. 
		</descr>
		<param name="sampleCount" type="integer" default="1">Number of generated samples / samples per pixel</param>
	</plugin>

	<plugin type="sampler" name="hammersley" readableName="Hammersley sequence" className="HammersleySequence" extends="Sampler">
		<descr>
			Deterministic 2D sample generator based on the Hammersley sequence. Internally
			uses a table of prime numbers to provide elements of the sequence up to a
			depth of 1000.
			Because of the high correlation amongst neighboring pixels, this
			sampler, by itself, is not meant to be used as a source of random numbers 
			for sample-based integrators such as <tt>direct</tt>, <tt>volpath</tt> etc. 
		</descr>
		<param name="sampleCount" type="integer" default="1">Number of generated samples / samples per pixel</param>
	</plugin>
</documentation>
